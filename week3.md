CRUD 

CRUD는 대부분의 컴퓨터가 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다. 사용자 인터페이스가 갖추어야 할 기능을 가리키는 용어로서도 사용된다.

객체지향 언어의 특성

1. 캡슐화 (Encapsulation)

객체지향 프로그래밍을 할때 있어서 매우 중요한 특징으로 서로 연관이 있는 데이터와 알고리즘을 하나로 묶어서 하나의 캡슐과 같은 형태로 만드는것이다. 이때 서로 연관이 없는 다른 객체의 접근을 제한하기 위해서 접근 제한 수식자의 기능을 제공한다. 이 기능 덕분에 데이터와 알고리즘이 다른 정보로 인해서 손상이 되거나 오류가 발생할 가능성을 최소화시키는 것이 가능하며 데이터가 바뀌더라도 사용방법은 바뀌지 않아서 다른 객체에 영향을 끼치지 않는다 그리고 독립성이 유지되면서 객체 간의 결합도가 낮아져서 인터페이스가 간단해지는 효과를 얻을 수 있다.

2. 상속 (Inheritance)

상속이란 소프트웨어 개발자들이 클래스들 간의 관계를 정립하는데 있어서 상위 클래스와 하위 클래스를 구분하게 되는데 이때 상위 클래스의 모든 것을 하위 클래스가 이어 받는 것을 상속이라고 표현한다. 
ex) 상위 클래스는 A는 3개의 데이터 (a,b,c)와 함수 3개(funcA(),funcB(),funcC())를 가지고 하위 클래스 B는 2개의 데이터(d,e)와 함수 2개(funcD(),funcE()) 를 가지고있으며 하위 클래스 C는 2개의 데이터(f,g)와 함수 2개(funcF(),funcG())를 가지고 있다고 하면 B와C는 상위 클래스 A에 있는 데이터와 함수를 상속받아서 활용할 수 있다.

3. 다형성 (Polymorphism)

다형성이란 여러 개의 형태를 가진다는 의미이다. 하지만 프로그래밍 언어에서는 상속과 연관이 있는 개념으로 사용이 되며 하나의 객체가 다른 여러 객체로 재구성이 되는 것을 의미한다. 다형성을 나타냐는 예시로는 오버 로딩과 오버라이딩이 있다. 프로그래밍에서 오버 로딩이란 메서드 중복 정의 오버라이딩이랑 메서드 재정의를 의미한다.

메서드 오버 로딩이란 이름이 동일한 메서드가 하나의 클래스 안에서 중복해서 정의되어 있는 경우를 의미한다. 동일한 이름의 메서드가 있으면 구분을 할 수 없기 때문에 매개변수를 다르게 해서 메서드를 구분해 주게 된다.

![정리1](https://user-images.githubusercontent.com/60682087/147115400-4061fef1-956d-4a6f-b0e0-0c4a5017f4e7.png)

메서드 오버라이딩도 메서드 오버 로딩처럼 상속에서 발생하게 되는데 오버라이딩은 상위 클래스에서 정의를 한 메서드를 하위 클래스에서 상속을 받아왔을때 상위 클래스의 정의를 전부 무시하고 다시 재정의해서 사용하는 것을 의미한다.

4.추상화 (Abstraction)

추상화란 공통된 속성이나 기능을 묶어서 이름을 붙이는 것으로 객체지향적 관점에서 클래스를 정의하는 것이 추상화라고 볼수있다. 

예시)

어떤한 물건들이 있을때 이 물건들의 공통된 특성을 통해서 해당 물건들을 모두 포함하는 단어로 물건들을 설명하는 것을 추상화로 볼 수 있다.
추상화는 다른 객체들과 구분되는 핵심적인 특징들에만 집중하면서 복잡도를 관리할 수 있도록 하는 효과를 가져오게된다. 이때 주의할 점은 추상화는 문제 영역과 관점에 의존적이라는 것으로 어떤 영역에서 중요한 것이 다른 영역에서는 중요하지 않을 수도 있어서 하나의 대상이라도 목적에 따라서 여러 추상화 모델이 만들어지게 될 수 있다.

절차지향프로그래밍 

어떠한 명령어들을 어떠한 순서로 몇 번 실행시킬지를 생각해두고 하는 프로그래밍 컴퓨터의 처리과정과 비슷하다. 
실행 속도가 빠르다는 장점이 있다. 
코드가 길어질수록 이해하기 쉽지 않다는 단점이 있다.

객체지향프로그래밍

실제 세계에서의 소통방식을 프로그래밍으로 구현한 것과도 같다. 어떠한 대상에 필요한 변수들이나 함수들을 하나의 조립단위로 묶어 객체라고 부른다. 실행속도가 절차지향프로그래밍에 비해 느리지만, 코드가 길어져도 이해하기가 쉽다. 또한 변수의 이름이 겹칠 위험도 적다.

클래스

클래스란 객체를 정의해녾은것 또는 객체의 설계도, 틀 이라고 정의할 수 있다.
클래스는 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다.

객체

객체란 사전적인 정의로 실제 존재하는 것이다. 객체지향 이론에서는 사물과 같은 유형적인 것뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다. 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다. 

필드(field)

필드(field) : 클래스 안에서 선언되는 멤버변수
지역 변수(local variable) : 메소드 블록 안에서 선언되는 변수 

<pre><code>
Class {
    Public int speed  { // 필드
    Void start(int s)  { //매개 변수
    Int t; // 지역 변수 
    }
  }
}
</pre></code>

필드를 선언 할 때는 접근 지정자, 필드의 타입, 필드의 이름 세가지를 정해줘야 한다. 접근 지정자에는 public과 private가 있으며, public은 모든 클래스로 부터 접근가능, private는 클래스 내부에서만 접근가능하다.

접근자와 설정자

접근자(accessor) : 필드 값을 반환한다. 일반적으로 게터(getter)라고 부르기도 한다.

설정자(mutator) : 필드 값을 설정한다. 일반적으로 세터(setter)라고 부르기도 한다.

<pre><code>
class Car {

    String color;

    public String getColor() //접근자
    {
        return color;
    }
    public void setColor(String c) //설정자
    {
        color = c;
    }
}

public class CarTest1{

    public static void main(String[] args) {

        Car myCar = new Car();

        myCar.setColor = "RED"; //설정자 사용
        System.out.println(myCar.getColor); //접근자 사용
    }
}
</pre></code>

메소드 (method)

메소드를 선언할때는 접근 지정자,반환형,매개변수,메소드 내부 내용이 필요하다.
매개변수의 자료형이 다르면 메소드의 이름은 같아도 된다. 이러한 메소드들을 중복 메소드라고 한다. 하지만 중복 메소드는 코드 해석을 어렵게 만들 수 있으므로 주의 깊게 사용해야 한다.

필드의 접근 지정자

접근 지정자는 크게 클래스에 붙는 접근 지정자와 내부구성요소(멤버 + 생성자)에 붙는 접근 지정자로 나눌 수 있다.

클래스에 붙는 접근 지정자는 public, default가있다.

내부구성요소에는 붙는 접근 지정자는 public, protected, default, private가있다.

Public : 어디에서든 접근가능하다.

Private : 같은 클래스 혹은 같은 객체 안에서만 접근이 가능하다.

Protected : 같은 package안에서만 접근 가능하고, package가 달라도 상속 관계이면 접근이 가능하다.

Default : 같은 package 안에서만 접근이 가능하다.

클래스 구성

<pre><code>
public class Circle
// 필드(변수)
public int radius; // 원의 반지름 필드
public String name; // 원의 이름 필드

// 메소드
public Circle() { // 원의 생성자 메소드
}
public double getArea() { // 원의 면적 계산 메소드
    return 3.14 * radius * radius;
  }
}
</pre></code>

- 这个项目是我为了重新学习Java而做的项目（이 프로젝트는 내가 Java를 다시 공부하기위해서 만든 프로젝트입니다.）
